setup(){} идет раньше всех лайфсайкл хуков
вовзращенные переменные из setup(){} не реактивные, а в data(){} реактивные
refs в сетап делаются наоборот, сначала импортишь ref from vue, потом ретурнишь его и добавляешь к тэгу.
refs в сетап делают данные реактивными, в 99% случае он используется для этого
для того, чтобы вытащить данные из ref в сетапе, нужно писать .value от рефа, но при ретурне, он автоматом вытаскивает value
есть reactive, он тоже делает переменные реактивными, но в отличии от refa, в сетапе ему не нужно использовать .value, а напрямую обращаться к объектам ninja.age
Минус в reactive, что он не работает с примитивами
В общем ref лучше, т.к будет удобнее переиспользовать их в других компонентах
чтобы работать с computed, нужно его заимпортить и назвать переменную. Он в свою очередь работают с переменными созданами от рефа
для работы с watch, нужно его заимпортить, watch(1 параметр - название рефа, потом функция)
watchEffect срабатывает единожды при загрузке сетапа, его так же нужно импортить, watchEffect(()=>любая переменная которая изменяется внутри него, будет вызывать этот хук)
чтобы перестать прослушивать watcherы, нужно поместить его в переменную и вызывать данную переменную где-либо
Чтобы использовать props в сетапе, нужно принять его как параметр setup(props) и обращаться к пропсам, props.posts
Для использования лайфсайкл хуков в сетапе, нужно прописать название хука с приставкой on, onMounted, onCreate и тд. и импортировать его
При написании тестов, если вызывать метод триггер, то нужно его делать асинхронный и ожидать его, т.к он возвращает nextTick
nextTick = функция которая работает под капотом vue, но во время тестов сама не вызывается при триггере
Для асинхронных действий надо завернуть компонент в suspense, он уже есть изначально в Vue3, без него asyn setup() не будет работать
У suspense, есть template #default и template #fallback, 1 отвечает за загруженный компонент, а 2 что можно сделать пока компонент грузится
Если при создании класса указать private, то при обращении к этому объекту не будет доступен private метод
Метод readonly не дает права переизменять объекты, но можно просто к нему обратиться
flushPromises нужен для вызова внешних промисов, т.к nextTick работает только с внутренними промисами
для вызова запросов можно юзать jest.mock() в тесте
propType в пропсах во вью нужен для более четкого указания типа пропсов
У ref значения появляются после маунта компонентов, поэтому в сетапе у него может одно значение, а в маунте другое
contentEditable похож на инпут, для него необходимо задать ref, если нужно двухстороннее связывание нужно добавить слушать @input, на нем нельзя юзать v-model
v-html = тоже что и div.innerHtml
watch первый параметр отвечает за элемент, за которым будем следить. А второй параметр отвечает за значение, которое мы получим, есть и 3 параметр immediate,
он отвечает за загрузку ватчера во время сетапа чтобы не было пустоты, если элемент пустой
watchEffect является как и watch с 3 аргументами, но он ему не нужно задавать изначальное значение за которым нужно следить.
debounce вызывает функцию только с определенным интервалом, допустим debounce(foo, 1000), если ее вызвать раньше заданной времени, то счетчик обнулится
если в интерфейса TSa поставить знак вопроса, то это будет считаться опциональным
у сетапа есть аргумент ctx, в нем можно делать емиты
Чтобы корректно сделать эмит, нужно в компоненте с созданным эмитом зарегать его через emits, как пропсы
Для того, чтобы сделать v-model в тестах, используется setValue('значение новой переменной')
Чтобы протестить эмит ивент, надо прописать wrapper.emitted()['название ивента'][индекс ивента][индекс ивента] 
Если эмитов несколько, они содержатся в массиве поэтому нужно обращаться к индексам
Чтобы использовать модули как плагин, нужно его классу задать install(app: App) и можно в main.ts использовать app.use(имя плагина)
В идеале тесты должны проводиться в замкнутой среде, т.к изменения в сторе могут повлиять на весь тест, поэтому провайд и инджект хорошая штука
В тесте при маунте компонента, есть второй параметр global: {plugins: [имя плагина]}, туда можно поставить стор и он отдельно вызывает для него
Тег <component :is='Название компонента которое будет вставляться'> означает, что компонент внутри него будет рендериться динамично
Чтобы не было ошибок, динамичную компоненту можно обернуть в markRaw
Если хотите использовать async setup(){}, то нужно компоненту которая юзает это, обернуть в <suspense>
можно сделать фейк router-link в тесте, используя RouterLinkStub